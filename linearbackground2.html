<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #000;
            color: white;
        }
        canvas {
            border: 2px solid #333;
            display: block;
            margin: 20px auto;
        }
        .controls {
            text-align: center;
            margin: 20px;
        }
        .color-input {
            margin: 10px;
        }
        label {
            display: inline-block;
            width: 100px;
            text-align: right;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <h1>WebGL Gradient Background</h1>
    <canvas id="canvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <div class="color-input">
            <label>Top Color:</label>
            <input type="color" id="topColor" value="#334d80">
        </div>
        <div class="color-input">
            <label>Bottom Color:</label>
            <input type="color" id="bottomColor" value="#ccd9e6">
        </div>
        <div class="color-input">
            <label>Direction:</label>
            <select id="direction">
                <option value="vertical">Vertical</option>
                <option value="horizontal">Horizontal</option>
                <option value="diagonal">Diagonal</option>
                <option value="radial">Radial</option>
            </select>
        </div>
    </div>

    <div style="max-width: 800px; margin: 0 auto; padding: 20px; background: #111; border-radius: 8px;">
        <h3>How it works:</h3>
        <p><strong>1. Vertex Shader:</strong> Creates a full-screen quad and passes position data to fragments</p>
        <p><strong>2. Fragment Shader:</strong> Uses the interpolated position to calculate a gradient value</p>
        <p><strong>3. mix() function:</strong> Blends between two colors based on the gradient value</p>
        <p><strong>4. Position mapping:</strong> Converts -1 to 1 coordinates into 0 to 1 for the gradient</p>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }

        // Vertex shader - creates full screen quad
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_position;

            void main() {
                gl_Position = vec4(a_position, 0, 1);
                v_position = a_position;
            }
        `;

        // Fragment shader - creates gradient based on position
        const fragmentShaderSource = `
            precision mediump float;
            varying vec2 v_position;
            uniform vec3 u_topColor;
            uniform vec3 u_bottomColor;
            uniform int u_direction;

            void main() {
                float gradient;
                
                if (u_direction == 0) {
                    // Vertical gradient
                    gradient = (v_position.y + 1.0) * 0.5;
                } else if (u_direction == 1) {
                    // Horizontal gradient
                    gradient = (v_position.x + 1.0) * 0.5;
                } else if (u_direction == 2) {
                    // Diagonal gradient
                    gradient = ((v_position.x + v_position.y) + 2.0) * 0.25;
                } else {
                    // Radial gradient
                    float dist = length(v_position);
                    gradient = smoothstep(0.0, 1.4, dist);
                }
                
                vec3 color = mix(u_bottomColor, u_topColor, gradient);
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Helper function to create and compile shaders
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        // Create shaders
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        // Create and link program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(program));
        }

        // Get attribute and uniform locations
        const positionAttribute = gl.getAttribLocation(program, 'a_position');
        const topColorUniform = gl.getUniformLocation(program, 'u_topColor');
        const bottomColorUniform = gl.getUniformLocation(program, 'u_bottomColor');
        const directionUniform = gl.getUniformLocation(program, 'u_direction');

        // Create buffer for full-screen quad
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        
        // Full-screen quad vertices (two triangles)
        const positions = [
            -1, -1,  // bottom left
             1, -1,  // bottom right
            -1,  1,  // top left
            -1,  1,  // top left
             1, -1,  // bottom right
             1,  1   // top right
        ];
        
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        // Helper function to convert hex color to RGB array
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return [r, g, b];
        }

        // Render function
        function render() {
            // Set viewport
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            // Clear canvas
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // Use our shader program
            gl.useProgram(program);
            
            // Set up vertex data
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionAttribute);
            gl.vertexAttribPointer(positionAttribute, 2, gl.FLOAT, false, 0, 0);
            
            // Set uniforms
            const topColor = hexToRgb(document.getElementById('topColor').value);
            const bottomColor = hexToRgb(document.getElementById('bottomColor').value);
            const direction = document.getElementById('direction').selectedIndex;
            
            gl.uniform3fv(topColorUniform, topColor);
            gl.uniform3fv(bottomColorUniform, bottomColor);
            gl.uniform1i(directionUniform, direction);
            
            // Draw the quad
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        // Set up event listeners
        document.getElementById('topColor').addEventListener('input', render);
        document.getElementById('bottomColor').addEventListener('input', render);
        document.getElementById('direction').addEventListener('change', render);

        // Initial render
        render();
    </script>
</body>
</html>