<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        canvas{
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas></canvas>

    <script>
        const canvas = document.querySelector("canvas");
        const log = console.log;

        // const gl = canvas.getContext("webgl");
        const gl = canvas.getContext("webgl");
        if(!gl){
            alert("WebGL is not supportedf");
        }
        
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main(){
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `
        const fragmentShaderSource = `
            precision mediump float;
            void main(){
                gl_FragColor = vec4(1,0,0,1);
            }
        `
        
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);

        //create a program and link
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        const vertices = new Float32Array([
            0.0,  0.5,  
            -0.5, -0.5, 
             0.5, -0.5,
        ]);

        const buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'a_position');
        // const colorLocation  = gl.getAttribLocation(program, 'a_color');

        gl.clearColor(0,0,0,1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(program);
        gl.enableVertexAttribArray(positionLoc);

        gl.vertexAttribPointer(positionLoc, 2,gl.FLOAT, false,0,0) 

        gl.drawArrays(gl.TRIANGLES,0,3);


        window.addEventListener("resize", () => {
            canvas.width = window.innerWidth
            canvas.height = window.innerHeight
            gl.viewport(0,0,canvas.width, canvas.height);

            gl.clearColor(0,0,0,1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.enableVertexAttribArray(positionLoc);

            gl.vertexAttribPointer(positionLoc,2,gl.FLOAT, false,0,0)

            gl.drawArrays(gl.TRIANGLES,0,3);
        })


        const buffer1 = new ArrayBuffer(10);
        buffer1[0] = 50;
        console.log(buffer1[0]); // undefined

        // Method 2 - With view (WORKS)
        const buffer2 = new ArrayBuffer(10);
        const view2 = new Uint8Array(buffer2);
        view2[0] = 50;
        console.log(view2[0]); // 50


        const myItems = new ArrayBuffer(2)

        myItems[0] = "sword"
        addItem("axe")
        addItem("spear")
        addItem("knife")
        addItem("bow")
        function addItem(item){
            let haveStored = false
            for(var i =0;i<myItems.byteLength;i++){
                if(haveStored) return;
                if(myItems[i] === undefined && !haveStored) {
                    myItems[i] = item;
                    haveStored = true;
                }
            }
        }
        log(myItems)

        
        const realArrBuff = new ArrayBuffer(20);
        const nums = new Float32Array(realArrBuff, realArrBuff.byteLength)
        log(nums);
        // const vertexShaderSource = `
        //     attribute vec2 position;
        //     void main(){
        //         gl_Position = vec4(position, 0.0, 1.0);
        //     }
        // `
        // const fragmentShaderSource = `
        //     precision mediump float;
        //     void main(){
        //         gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // red color
        //     }
        // `
        // function createShader(gl, type, source) {
        //     const shader = gl.createShader(type);
        //     gl.shaderSource(shader, source);
        //     gl.compileShader(shader);
            
        //     if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        //         gl.deleteShader(shader);
        //         return null;
        //     }
            
        //     return shader;
        // }

        // const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        // const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        
        // // Create and link the program
        // const program = gl.createProgram();
        // gl.attachShader(program, vertexShader);
        // gl.attachShader(program, fragmentShader);
        // gl.linkProgram(program);

        if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
            log("program link error")
        }

        // const vertices = new Float32Array([
        //     0.0,  0.5,   // Top vertex
        //    -0.5, -0.5,   // Bottom left
        //     0.5, -0.5    // Bottom right
        // ]);

        // const buffer = gl.createBuffer();
        // gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        // gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        // const positionLoc = gl.getAttribLocation(program, 'position');

        // gl.clearColor(0,0,0,1);
        // gl.clear(gl.COLOR_BUFFER_BIT);

        // gl.useProgram(program);
        // gl.enableVertexAttribArray(positionLoc);

        // gl.vertexAttribPointer(positionLoc,2,gl.FLOAT, false,0,0)
        // gl.drawArrays(gl.TRIANGLES,0,3);

        // log("Success Drawn")









        
        // function resizeCanvas(){
        //     canvas.width = window.innerWidth;
        //     canvas.height = window.innerHeight;
        //     gl.viewport(0,0,canvas.width, canvas.height)
        // }

        // resizeCanvas();
        // window.addEventListener("resize", resizeCanvas);

        // const vertexShaderSource = `
        //     attribute vec3 position;
        //     attribute vec3 normal;
        //     attribute vec2 texCoord;

        //     uniform mat4 modelMatrix;
        //     uniform mat4 viewMatrix;
        //     uniform mat4 projMatrix;

        //     varying vec3 vNormal;
        //     varying vec3 vPosition;
        //     varying vec2 vTexCoord;

        //     void main(){
        //         vec4 worldPos = modelMatrix * vec4(position, 1.0);
        //         vPosition = worldPos.xyz;

        //         vec4 viewPos = viewMatrix * worldPos;

        //     }
        // `
    </script>
</body>
</html>