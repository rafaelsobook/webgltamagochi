<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <canvas id="canvas" width="400" height="400"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        const log = console.log

        if (!gl) {
            console.error('WebGL not supported or disabled. Please check your browser settings.');
            alert('WebGL not supported or disabled. Please check your browser settings.');
            throw new Error('WebGL not supported');
        }

        const vertexShaderSource = `
            attribute vec2 position;
            void main(){
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `
        const fragmentShaderSource = `
            precision mediump float;
            void main(){
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // red color
            }
        `
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        
        // Create and link the program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
            log("program link error")
        }

        const vertices = new Float32Array([
            0.0,  0.5,   // Top vertex
           -0.5, -0.5,   // Bottom left
            0.5, -0.5    // Bottom right
        ]);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'position');

        gl.clearColor(0,0,0,1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(program);
        gl.enableVertexAttribArray(positionLoc);

        gl.vertexAttribPointer(positionLoc,2,gl.FLOAT, false,0,0)
        gl.drawArrays(gl.TRIANGLES,0,3);

        gl.drawArrays(gl.TRIANGLES,)

        log("Success Drawn")

        // console.log('WebGL initialized successfully');

        // // Vertex shader
        // const vertexShaderSource = `
        //     attribute vec2 a_position;
        //     attribute vec4 a_color;
        //     varying vec4 v_color;
            
        //     void main() {
        //         gl_Position = vec4(a_position, 0.0, 1.0);
        //         v_color = a_color;
        //     }
        // `;

        // // Fragment shader
        // const fragmentShaderSource = `
        //     precision mediump float;
        //     varying vec4 v_color;
            
        //     void main() {
        //         gl_FragColor = v_color;
        //     }
        // `;

        // // Create shader
        // function createShader(gl, type, source) {
        //     const shader = gl.createShader(type);
        //     gl.shaderSource(shader, source);
        //     gl.compileShader(shader);
            
        //     if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        //         console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        //         gl.deleteShader(shader);
        //         return null;
        //     }
            
        //     return shader;
        // }

        // // Create program
        // const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        // const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        // if (!vertexShader || !fragmentShader) {
        //     throw new Error('Failed to create shaders');
        // }

        // const program = gl.createProgram();
        // gl.attachShader(program, vertexShader);
        // gl.attachShader(program, fragmentShader);
        // gl.linkProgram(program);
        // gl.useProgram(program)

        // if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        //     console.error('Program link error:', gl.getProgramInfoLog(program));
        //     throw new Error('Failed to link WebGL program');
        // }

        // console.log('Shaders compiled and program linked successfully');

        // // HERE'S THE ARRAYBUFFER EXAMPLE:
        // // Create vertex data using ArrayBuffer (memory efficient!)
        // const buffer = new ArrayBuffer(18); // 3 vertices × 6 floats × 4 bytes = 72 bytes

        // const vertexData = new Float32Array([
        //     // Top vertex (red)
        //      0.0,  0.5,  1.0, 0.0, 0.0, 1.0,
        //     // Bottom left (green)
        //     -0.5, -0.5,  0.0, 1.0, 0.0, 1.0,
        //     // Bottom right (blue)
        //      0.5, -0.5,  0.0, 0.0, 1.0, 1.0
        // ]);

        // // Fill the buffer with vertex data: [x, y, r, g, b, a]
        // // vertexData.set();

        // console.log('ArrayBuffer size:', buffer.byteLength, 'bytes');
        // console.log('Vertex data:', vertexData);

        // // Create WebGL buffer and upload data
        // const webglBuffer = gl.createBuffer();
        // gl.bindBuffer(gl.ARRAY_BUFFER, webglBuffer);
        // gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);

        // // Get attribute locations
        // const positionLocation = gl.getAttribLocation(program, 'a_position');
        // const colorLocation = gl.getAttribLocation(program, 'a_color');

        // if (positionLocation === -1 || colorLocation === -1) {
        //     throw new Error('Failed to get attribute locations');
        // }

        // console.log('Attribute locations retrieved successfully');

        // // Setup rendering
        // gl.useProgram(program);
        // gl.viewport(0, 0, canvas.width, canvas.height);
        // gl.clearColor(0.9, 0.9, 0.9, 1.0);

        // // Enable attributes
        // gl.enableVertexAttribArray(positionLocation);
        // gl.enableVertexAttribArray(colorLocation);

        // // Tell WebGL how to read the buffer
        // // Position: 2 floats, starting at byte 0, stride 24 bytes (6 floats × 4 bytes)
        // gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 24, 0);
        
        // // Color: 4 floats, starting at byte 8 (after 2 position floats), stride 24 bytes
        // gl.vertexAttribPointer(colorLocation, 4, gl.FLOAT, false, 24, 8);

        // // Render
        // gl.clear(gl.COLOR_BUFFER_BIT);
        // gl.drawArrays(gl.TRIANGLES, 0, 3);

        // // Show memory comparison
        // setTimeout(() => {
        //     console.log('\n=== MEMORY COMPARISON ===');
            
        //     // Regular JavaScript array approach
        //     const regularArray = [
        //         0.0, 0.5, 1.0, 0.0, 0.0, 1.0,
        //         -0.5, -0.5, 0.0, 1.0, 0.0, 1.0,
        //         0.5, -0.5, 0.0, 0.0, 1.0, 1.0
        //     ];
            
        //     console.log('Regular array approach:');
        //     console.log('- Each number: ~8 bytes (JavaScript number)');
        //     console.log('- Total: ~', regularArray.length * 8, 'bytes');
            
        //     console.log('\nArrayBuffer approach:');
        //     console.log('- Each float: exactly 4 bytes');
        //     console.log('- Total:', buffer.byteLength, 'bytes');
        //     console.log('- Memory saved:', (regularArray.length * 8) - buffer.byteLength, 'bytes');
        // }, 1000);
    </script>
</body>
</html>