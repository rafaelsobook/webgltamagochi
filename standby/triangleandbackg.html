<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL GLB Loader - Fixed</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #222;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 300px;
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info" id="info">Loading GLB model...</div>
    <div class="controls">
        <div>Mouse: Rotate camera</div>
        <div>Wheel: Zoom in/out</div>
        <div>R: Reset view</div>
    </div>

<script>
    const canvas = document.querySelector("canvas")
    const gl = canvas.getContext('webgl');
    
    function resizeCanvas(){
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0,0, canvas.width, canvas.height)
    }
    resizeCanvas();

    const triangleVertexSource = `
        attribute vec2 a_position;
        void main(){
            gl_Position = vec4(a_position, 0, 1);
        }
    `
    const triangleFragmentSource = `
        precision mediump float;
        void main(){
            gl_FragColor = vec4(1,0,0,1);
        }
    `

    const vertexSource = `
        attribute vec2 a_position;
        varying vec2 v_position;
        void main(){
            gl_Position = vec4(a_position,0,1);
            v_position = a_position;
        }
    `
    const gradientSource = `
        precision mediump float;
        varying vec2 v_position;
        void main(){
            float gradient = (v_position.y + 1.0) * 0.5;
            vec3 topColor = vec3(0.2, 0.3, 0.5);
            vec3 bottomColor = vec3(0.8, 0.85, 0.9);

            vec3 color = mix(bottomColor, topColor, gradient);
            gl_FragColor = vec4(color, 1.0);
        }
    `;

    function createShader(gl, type, source){
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
    }
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource)
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, gradientSource)

    const triangleVShader = createShader(gl, gl.VERTEX_SHADER, triangleVertexSource)
    const triangleFShader = createShader(gl, gl.FRAGMENT_SHADER, triangleFragmentSource)

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    const  triangleProgram  = gl.createProgram();
    gl.attachShader(triangleProgram, triangleVShader);
    gl.attachShader(triangleProgram, triangleFShader);
    gl.linkProgram(triangleProgram);

    const positionAttribute = gl.getAttribLocation(program, "a_position");
    const trianglePosAttribute = gl.getAttribLocation(triangleProgram, "a_position")
    
    const positionBuffer = gl.createBuffer()
    const positions = new Float32Array([
        -1,-1,
        1,-1,
        -1,1,
        -1,1,
        1,-1,
        1,1
    ])

    const triangleBuffer = gl.createBuffer()
    const vertices = new Float32Array([
        -0.5,-0.5,
        0.5, -0.5,
        0, 0.5
    ])

    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.clear(gl.DEPTH_BUFFER_BIT);
    gl.clearColor(0,0,0,1);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);


    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    activateAnddraw(program, positionBuffer, positionAttribute, positions.length);
    activateAnddraw(triangleProgram, triangleBuffer, trianglePosAttribute, vertices.length);

    function activateAnddraw(linkedprogram, buffer, vertexAttribute, vertexCount){
        gl.useProgram(linkedprogram);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.enableVertexAttribArray(vertexAttribute);
        gl.vertexAttribPointer(vertexAttribute, 2, gl.FLOAT, false, 0,0);
        gl.drawArrays(gl.TRIANGLES, 0,vertexCount)
    }
    function resize(){
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        gl.clearColor(0,0,0,1);
        resizeCanvas();
        const aspect = canvas.width/canvas.height;
        const newVertices = new Float32Array([
            -0.5/aspect,-0.5,
            0.5/aspect, -0.5,
            0/aspect, 0.5
        ])

        gl.bindBuffer(gl.ARRAY_BUFFER, triangleBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, newVertices, gl.STATIC_DRAW);

        activateAnddraw(program, positionBuffer, positionAttribute, positions.length);
        activateAnddraw(triangleProgram, triangleBuffer, trianglePosAttribute, vertices.length);

    }
    resize();
    window.addEventListener("resize", resize);
    // gl.clear(gl.COLOR_BUFFER_BIT);
    // gl.clear(gl.DEPTH_BUFFER_BIT);
    // gl.clearColor(0,0,0,1);
</script>
</body>
</html>