<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL GLB Loader - Fixed</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #222;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 300px;
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info" id="info">Loading GLB model...</div>
    <div class="controls">
        <div>Mouse: Rotate camera</div>
        <div>Wheel: Zoom in/out</div>
        <div>R: Reset view</div>
    </div>

    <script>
        let gl, program, positionBuffer, normalBuffer, indexBuffer;
        let modelMatrix = mat4_identity();
        let viewMatrix = mat4_identity();
        let projectionMatrix = mat4_identity();
        let normalMatrix = mat4_identity();
        let rotation = 0;
        
        // Camera controls
        let cameraDistance = 5;
        let cameraRotationX = 0;
        let cameraRotationY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // Vertex shader source with improved lighting
        const vertexShaderSource = `
            attribute vec3 a_position;
            attribute vec3 a_normal;
            uniform mat4 u_model;
            uniform mat4 u_view;
            uniform mat4 u_projection;
            uniform mat4 u_normalMatrix;
            uniform vec3 u_lightDirection;
            uniform vec3 u_viewPosition;
            
            varying vec3 v_normal;
            varying vec3 v_position;
            varying vec3 v_lighting;
            
            void main() {
                vec4 worldPosition = u_model * vec4(a_position, 1.0);
                gl_Position = u_projection * u_view * worldPosition;
                
                // Transform normal to world space
                v_normal = normalize((u_normalMatrix * vec4(a_normal, 0.0)).xyz);
                v_position = worldPosition.xyz;
                
                // Calculate lighting in vertex shader for better performance
                vec3 lightDir = normalize(u_lightDirection);
                float NdotL = max(dot(v_normal, lightDir), 0.0);
                
                // Ambient + Diffuse lighting
                vec3 ambient = vec3(0.4, 0.4, 0.4);
                vec3 diffuse = vec3(0.8, 0.8, 0.8) * NdotL;
                
                // Add some rim lighting for better visibility
                vec3 viewDir = normalize(u_viewPosition - v_position);
                float rim = 1.0 - max(dot(viewDir, v_normal), 0.0);
                vec3 rimLight = vec3(0.2, 0.2, 0.3) * pow(rim, 2.0);
                
                v_lighting = ambient + diffuse + rimLight;
            }
        `;
        
        // Fragment shader source with brighter colors
        const fragmentShaderSource = `
            precision mediump float;
            varying vec3 v_normal;
            varying vec3 v_position;
            varying vec3 v_lighting;
            
            void main() {
                // Brighter base color
                vec3 baseColor = vec3(0.7, 0.5, 0.3);
                
                // Ensure minimum brightness
                vec3 finalColor = baseColor * max(v_lighting, vec3(0.3));
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;
        
        // Initialize WebGL
        function initWebGL() {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            gl = canvas.getContext('webgl');
            if (!gl) {
                console.error('WebGL not supported');
                updateInfo('‚ùå WebGL not supported');
                return false;
            }
            
            console.log('WebGL context initialized');
            updateInfo('‚úÖ WebGL initialized');
            
            // Create shader program
            program = createShaderProgram(gl, vertexShaderSource, fragmentShaderSource);
            if (!program) {
                updateInfo('‚ùå Shader compilation failed');
                return false;
            }
            gl.useProgram(program);
            
            // Set up viewport and enable depth testing
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.enable(gl.DEPTH_TEST);
            // gl.enable(gl.CULL_FACE);
            // gl.cullFace(gl.BACK);
            gl.clearColor(1,0,0,1);
            
            // Set up projection matrix
            const aspect = canvas.width / canvas.height;
            projectionMatrix = mat4_perspective(45 * Math.PI / 180, aspect, 0.1, 1000.0);
            
            // Set up initial view matrix
            updateViewMatrix();
            
            // Create buffers
            positionBuffer = gl.createBuffer();
            normalBuffer = gl.createBuffer();
            indexBuffer = gl.createBuffer();
            
            // Set up mouse controls
            setupControls(canvas);
            
            return true;
        }
        
        function updateInfo(message) {
            document.getElementById('info').textContent = message;
        }
        
        function setupControls(canvas) {
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    cameraRotationY += deltaX * 0.01;
                    cameraRotationX += deltaY * 0.01;
                    
                    // Clamp vertical rotation
                    cameraRotationX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraRotationX));
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    
                    updateViewMatrix();
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.01;
                cameraDistance = Math.max(0.5, Math.min(50, cameraDistance));
                updateViewMatrix();
            });
            
            window.addEventListener('keydown', (e) => {
                if (e.key === 'r' || e.key === 'R') {
                    // Reset camera
                    cameraDistance = 5;
                    cameraRotationX = 0;
                    cameraRotationY = 0;
                    updateViewMatrix();
                }
            });
        }
        
        function updateViewMatrix() {
            const x = cameraDistance * Math.sin(cameraRotationY) * Math.cos(cameraRotationX);
            const y = cameraDistance * Math.sin(cameraRotationX);
            const z = cameraDistance * Math.cos(cameraRotationY) * Math.cos(cameraRotationX);
            
            viewMatrix = mat4_lookAt([x, y, z], [0, 0, 0], [0, 1, 0]);
        }
        
        // Create and compile shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        // Create shader program
        function createShaderProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
            
            if (!vertexShader || !fragmentShader) return null;
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return null;
            }
            
            return program;
        }
        
        // Load GLB model
        async function loadGLBModel(url = './model.glb') {
            try {
                console.log('Fetching GLB:', url);
                updateInfo('üì• Fetching GLB model...');
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} - Make sure model.glb exists`);
                }
                
                console.log('GLB fetch successful, parsing binary data...');
                updateInfo('üîÑ Parsing GLB data...');
                
                const arrayBuffer = await response.arrayBuffer();
                const gltfData = parseGLB(arrayBuffer);
                
                if (gltfData && gltfData.meshes && gltfData.meshes.length > 0) {
                    createMeshBuffers(gltfData);
                    updateInfo(`‚úÖ GLB model loaded! Vertices: ${window.vertexCount}`);
                } else {
                    createFallbackCube();
                    updateInfo('üì¶ No mesh data found, showing test cube');
                }
                
            } catch (error) {
                console.error('‚ùå GLB loading failed:', error.message);
                updateInfo(`‚ùå GLB loading failed: ${error.message}`);
                createFallbackCube();
            }
        }
        
        // Parse GLB binary format
        function parseGLB(arrayBuffer) {
            try {
                console.log(`GLB file size: ${arrayBuffer.byteLength} bytes`);
                const view = new DataView(arrayBuffer);
                
                // Read GLB header
                const magic = view.getUint32(0, true);
                const version = view.getUint32(4, true);
                const length = view.getUint32(8, true);
                
                if (magic !== 0x46546C67) {
                    throw new Error('Not a valid GLB file');
                }
                
                if (version !== 2) {
                    throw new Error('Only GLB version 2 is supported');
                }
                
                // Read JSON chunk
                const jsonChunkLength = view.getUint32(12, true);
                const jsonChunkType = view.getUint32(16, true);
                
                if (jsonChunkType !== 0x4E4F534A) {
                    throw new Error('Expected JSON chunk');
                }
                
                // Extract JSON
                const jsonBytes = new Uint8Array(arrayBuffer, 20, jsonChunkLength);
                const jsonString = new TextDecoder().decode(jsonBytes);
                const gltf = JSON.parse(jsonString);
                
                // Check for binary chunk
                const binChunkOffset = 20 + jsonChunkLength;
                let binaryData = null;
                
                if (binChunkOffset < arrayBuffer.byteLength) {
                    const binChunkLength = view.getUint32(binChunkOffset, true);
                    const binChunkType = view.getUint32(binChunkOffset + 4, true);
                    
                    if (binChunkType === 0x004E4942) {
                        binaryData = new Uint8Array(arrayBuffer, binChunkOffset + 8, binChunkLength);
                    }
                }
                
                gltf.binaryData = binaryData;
                return gltf;
                
            } catch (error) {
                console.error('GLB parsing error:', error);
                return null;
            }
        }
        
        // Extract mesh data from GLTF and create WebGL buffers
        function createMeshBuffers(gltf) {
            try {
                const mesh = gltf.meshes[0];
                const primitive = mesh.primitives[0];
                
                // Get position data
                const positionAccessor = gltf.accessors[primitive.attributes.POSITION];
                const positionBufferView = gltf.bufferViews[positionAccessor.bufferView];
                const positionOffset = (positionBufferView.byteOffset || 0) + (positionAccessor.byteOffset || 0);
                const positionData = new Float32Array(
                    gltf.binaryData.buffer,
                    gltf.binaryData.byteOffset + positionOffset,
                    positionAccessor.count * 3
                );
                
                // Get or generate normals
                let normalData;
                if (primitive.attributes.NORMAL !== undefined) {
                    const normalAccessor = gltf.accessors[primitive.attributes.NORMAL];
                    const normalBufferView = gltf.bufferViews[normalAccessor.bufferView];
                    const normalOffset = (normalBufferView.byteOffset || 0) + (normalAccessor.byteOffset || 0);
                    
                    normalData = new Float32Array(
                        gltf.binaryData.buffer,
                        gltf.binaryData.byteOffset + normalOffset,
                        normalAccessor.count * 3
                    );
                } else {
                    // Generate normals pointing outward
                    normalData = generateNormals(positionData);
                }
                
                // Upload to WebGL buffers
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positionData, gl.STATIC_DRAW);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, normalData, gl.STATIC_DRAW);
                
                // Handle indices if present
                if (primitive.indices !== undefined) {
                    const indexAccessor = gltf.accessors[primitive.indices];
                    const indexBufferView = gltf.bufferViews[indexAccessor.bufferView];
                    const indexOffset = (indexBufferView.byteOffset || 0) + (indexAccessor.byteOffset || 0);
                    
                    let indexData;
                    if (indexAccessor.componentType === 5123) { // UNSIGNED_SHORT
                        indexData = new Uint16Array(
                            gltf.binaryData.buffer,
                            gltf.binaryData.byteOffset + indexOffset,
                            indexAccessor.count
                        );
                    } else if (indexAccessor.componentType === 5125) { // UNSIGNED_INT
                        indexData = new Uint32Array(
                            gltf.binaryData.buffer,
                            gltf.binaryData.byteOffset + indexOffset,
                            indexAccessor.count
                        );
                    }
                    
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
                    
                    window.indexCount = indexAccessor.count;
                    window.hasIndices = true;
                } else {
                    window.hasIndices = false;
                }
                
                window.vertexCount = positionAccessor.count;
                
                // Auto-scale and center the model
                const bounds = calculateBounds(positionData);
                const maxDimension = Math.max(bounds.width, bounds.height, bounds.depth);
                window.modelScale = maxDimension > 0 ? 2.0 / maxDimension : 1.0;
                window.modelCenter = [bounds.centerX, bounds.centerY, bounds.centerZ];
                
                console.log(`Model loaded: ${window.vertexCount} vertices, scale: ${window.modelScale.toFixed(3)}`);
                
            } catch (error) {
                console.error('Error extracting mesh data:', error);
                createFallbackCube();
            }
        }
        
        function generateNormals(positions) {
            const normals = new Float32Array(positions.length);
            
            // Simple normal generation for triangles
            for (let i = 0; i < positions.length; i += 9) {
                // Get triangle vertices
                const v1 = [positions[i], positions[i+1], positions[i+2]];
                const v2 = [positions[i+3], positions[i+4], positions[i+5]];
                const v3 = [positions[i+6], positions[i+7], positions[i+8]];
                
                // Calculate edges
                const edge1 = subtract(v2, v1);
                const edge2 = subtract(v3, v1);
                
                // Calculate normal
                const normal = normalize(cross(edge1, edge2));
                
                // Set normal for all three vertices
                for (let j = 0; j < 3; j++) {
                    normals[i + j*3] = normal[0];
                    normals[i + j*3 + 1] = normal[1];
                    normals[i + j*3 + 2] = normal[2];
                }
            }
            
            return normals;
        }
        
        // Calculate model bounding box
        function calculateBounds(positions) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            for (let i = 0; i < positions.length; i += 3) {
                minX = Math.min(minX, positions[i]);
                maxX = Math.max(maxX, positions[i]);
                minY = Math.min(minY, positions[i + 1]);
                maxY = Math.max(maxY, positions[i + 1]);
                minZ = Math.min(minZ, positions[i + 2]);
                maxZ = Math.max(maxZ, positions[i + 2]);
            }
            
            return {
                width: maxX - minX,
                height: maxY - minY,
                depth: maxZ - minZ,
                centerX: (minX + maxX) / 2,
                centerY: (minY + maxY) / 2,
                centerZ: (minZ + maxZ) / 2
            };
        }
        
        // Create fallback cube geometry with proper normals
        function createFallbackCube() {
            // Cube vertices (each face separate for proper normals)
            const vertices = [
                // Front face
                -1, -1,  1,   1, -1,  1,   1,  1,  1,
                -1, -1,  1,   1,  1,  1,  -1,  1,  1,
                
                // Back face  
                -1, -1, -1,  -1,  1, -1,   1,  1, -1,
                -1, -1, -1,   1,  1, -1,   1, -1, -1,
                
                // Top face
                -1,  1, -1,  -1,  1,  1,   1,  1,  1,
                -1,  1, -1,   1,  1,  1,   1,  1, -1,
                
                // Bottom face
                -1, -1, -1,   1, -1, -1,   1, -1,  1,
                -1, -1, -1,   1, -1,  1,  -1, -1,  1,
                
                // Right face
                 1, -1, -1,   1,  1, -1,   1,  1,  1,
                 1, -1, -1,   1,  1,  1,   1, -1,  1,
                
                // Left face
                -1, -1, -1,  -1, -1,  1,  -1,  1,  1,
                -1, -1, -1,  -1,  1,  1,  -1,  1, -1
            ];
            
            const normals = [
                // Front face
                0, 0, 1,  0, 0, 1,  0, 0, 1,
                0, 0, 1,  0, 0, 1,  0, 0, 1,
                
                // Back face
                0, 0, -1,  0, 0, -1,  0, 0, -1,
                0, 0, -1,  0, 0, -1,  0, 0, -1,
                
                // Top face
                0, 1, 0,  0, 1, 0,  0, 1, 0,
                0, 1, 0,  0, 1, 0,  0, 1, 0,
                
                // Bottom face
                0, -1, 0,  0, -1, 0,  0, -1, 0,
                0, -1, 0,  0, -1, 0,  0, -1, 0,
                
                // Right face
                1, 0, 0,  1, 0, 0,  1, 0, 0,
                1, 0, 0,  1, 0, 0,  1, 0, 0,
                
                // Left face
                -1, 0, 0,  -1, 0, 0,  -1, 0, 0,
                -1, 0, 0,  -1, 0, 0,  -1, 0, 0
            ];
            
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
            
            window.vertexCount = 36;
            window.modelScale = 1.0;
            window.modelCenter = [0, 0, 0];
            window.hasIndices = false;
        }
        
        // Render loop
        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // Auto-rotate model
            rotation += 0.005;
            
            // Create model matrix
            let scaleMatrix = mat4_scale(window.modelScale || 1.0);
            let centerMatrix = mat4_translate(
                -(window.modelCenter?.[0] || 0),
                -(window.modelCenter?.[1] || 0),
                -(window.modelCenter?.[2] || 0)
            );
            let rotationMatrix = mat4_rotationY(rotation);
            
            modelMatrix = mat4_multiply(rotationMatrix, mat4_multiply(scaleMatrix, centerMatrix));
            normalMatrix = mat4_transpose(mat4_invert(modelMatrix));
            
            // Set uniforms
            const modelLoc = gl.getUniformLocation(program, 'u_model');
            const viewLoc = gl.getUniformLocation(program, 'u_view');
            const projLoc = gl.getUniformLocation(program, 'u_projection');
            const normalMatrixLoc = gl.getUniformLocation(program, 'u_normalMatrix');
            const lightDirLoc = gl.getUniformLocation(program, 'u_lightDirection');
            const viewPosLoc = gl.getUniformLocation(program, 'u_viewPosition');
            
            gl.uniformMatrix4fv(modelLoc, false, modelMatrix);
            gl.uniformMatrix4fv(viewLoc, false, viewMatrix);
            gl.uniformMatrix4fv(projLoc, false, projectionMatrix);
            gl.uniformMatrix4fv(normalMatrixLoc, false, normalMatrix);
            gl.uniform3fv(lightDirLoc, [0.5, 1.0, 0.8]); // Bright light from top-right-front
            
            // Camera position for rim lighting
            const x = cameraDistance * Math.sin(cameraRotationY) * Math.cos(cameraRotationX);
            const y = cameraDistance * Math.sin(cameraRotationX);
            const z = cameraDistance * Math.cos(cameraRotationY) * Math.cos(cameraRotationX);
            gl.uniform3fv(viewPosLoc, [x, y, z]);
            
            // Bind position attribute
            const positionLoc = gl.getAttribLocation(program, 'a_position');
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
            
            // Bind normal attribute
            const normalLoc = gl.getAttribLocation(program, 'a_normal');
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.enableVertexAttribArray(normalLoc);
            gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);
            
            // Draw
            if (window.vertexCount) {
                if (window.hasIndices) {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                    gl.drawElements(gl.TRIANGLES, window.indexCount, gl.UNSIGNED_SHORT, 0);
                } else {
                    gl.drawArrays(gl.TRIANGLES, 0, window.vertexCount);
                }
            }
            
            requestAnimationFrame(render);
        }
        
        // Matrix math functions (same as before but more robust)
        function mat4_identity() {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]);
        }
        
        function mat4_perspective(fov, aspect, near, far) {
            const f = Math.tan(Math.PI * 0.5 - 0.5 * fov);
            const rangeInv = 1.0 / (near - far);
            
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (near + far) * rangeInv, -1,
                0, 0, near * far * rangeInv * 2, 0
            ]);
        }
        
        function mat4_lookAt(eye, target, up) {
            const zAxis = normalize(subtract(eye, target));
            const xAxis = normalize(cross(up, zAxis));
            const yAxis = normalize(cross(zAxis, xAxis));
            
            return new Float32Array([
                xAxis[0], yAxis[0], zAxis[0], 0,
                xAxis[1], yAxis[1], zAxis[1], 0,
                xAxis[2], yAxis[2], zAxis[2], 0,
                -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1,
            ]);
        }
        
        function mat4_rotationY(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            
            return new Float32Array([
                c, 0, s, 0,
                0, 1, 0, 0,
                -s, 0, c, 0,
                0, 0, 0, 1
            ]);
        }
        
        function mat4_scale(s) {
            return new Float32Array([
                s, 0, 0, 0,
                0, s, 0, 0,
                0, 0, s, 0,
                0, 0, 0, 1
            ]);
        }
        
        function mat4_translate(x, y, z) {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                x, y, z, 1
            ]);
        }
        
        function mat4_multiply(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] = 
                        a[i * 4 + 0] * b[0 * 4 + j] +
                        a[i * 4 + 1] * b[1 * 4 + j] +
                        a[i * 4 + 2] * b[2 * 4 + j] +
                        a[i * 4 + 3] * b[3 * 4 + j];
                }
            }
            return result;
        }
        
        function mat4_invert(m) {
            // Simplified inverse for rotation/scale matrices
            const result = new Float32Array(16);
            
            // For orthogonal matrices (rotation only), inverse = transpose
            result[0] = m[0]; result[1] = m[4]; result[2] = m[8]; result[3] = 0;
            result[4] = m[1]; result[5] = m[5]; result[6] = m[9]; result[7] = 0;
            result[8] = m[2]; result[9] = m[6]; result[10] = m[10]; result[11] = 0;
            result[12] = 0; result[13] = 0; result[14] = 0; result[15] = 1;
            
            return result;
        }
        
        function mat4_transpose(m) {
            return new Float32Array([
                m[0], m[4], m[8], m[12],
                m[1], m[5], m[9], m[13],
                m[2], m[6], m[10], m[14],
                m[3], m[7], m[11], m[15]
            ]);
        }
        
        // Vector math helpers
        function subtract(a, b) {
            return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
        }
        
        function cross(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }
        
        function dot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }
        
        function normalize(v) {
            const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            if (length === 0) return [0, 0, 1]; // Avoid division by zero
            return [v[0] / length, v[1] / length, v[2] / length];
        }
        
        // Handle window resize
        function handleResize() {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            if (gl) {
                gl.viewport(0, 0, canvas.width, canvas.height);
                const aspect = canvas.width / canvas.height;
                projectionMatrix = mat4_perspective(45 * Math.PI / 180, aspect, 0.1, 1000.0);
            }
        }
        
        // Initialize everything
        window.addEventListener('load', () => {
            if (initWebGL()) {
                console.log('WebGL GLB loader initialized');
                loadGLBModel('./model.glb');
                render();
            }
        });
        
        window.addEventListener('resize', handleResize);
    </script>
</body>
</html>